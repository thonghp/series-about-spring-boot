# Hiển thị form - Lưu thông tin và ảnh - Cập nhật

## Mục lục nội dung

- [1. Hiển thị form](#1-hiển-thị-form)
- [2. Lưu thông tin và ảnh](#2-lưu-thông-tin-và-ảnh)
- [3. Cập nhật](#3-cập-nhật)

## 1. Hiển thị form

- Để trả về form để thêm thông tin user ta cần thực hiện tạo controller xử lý request tạo mới

```java
// user.html
<div>
    <a th:href="@{/users/new}">Thêm nhân viên</a>
</div>

@GetMapping("/users/new")
public String newUser(Model model) {
    User user = new User();
    model.addAttribute("user", user);

    return "user_form";
}

// user_form.html
<form th:action="@{/users/save}" method="post" th:object="${user}">
    <input type="hidden" th:field="*{id}">
    ...
</form>
```

**[⬆ Quay trở lại đầu trang](#mục-lục-nội-dung)**

## 2. Lưu thông tin và ảnh

Để lưu user xuống database và lưu ảnh vào folder ta cần thực hiện các bước sau:

- B1: Viết service xử lý logic lưu thông tin user xuống database
- B2: Viết các method hỗ trợ lưu ảnh vô folder
- B3: Viết hàm controller xử lý request yêu cầu lưu user
- B4: Viết js/jquery xử lý kiểm tra kích thước của ảnh sau đó show thumbnail lên cho người dùng xem.
- B5: Viết file config xử lý cấu hình static resource

![form](/assets/day13.jpg)

**Class hỗ trợ lưu file ảnh vào thư mục**

- Sử dụng Logger cho phép ghi lại các thông điệp log về hoạt động của ứng dụng trong quá trình chạy, dễ dàng theo dõi lỗi
- Có các cấp độ log sau: **`DEBUG, INFO, WARNING, ERROR`**
- Nó sẽ hiển thị trong terminal khi có lỗi

```java
public class FileUploadUtils {
    private static final Logger LOGGER = LoggerFactory.getLogger(FileUploadUtils.class);
    public static void saveFile(String uploadDir, String fileName, MultipartFile multipartFile) throws IOException {
        // chuyển đổi đường dẫn tương đối thành tuyệt đối
        Path uploadPath = Paths.get(uploadDir);
        if (!Files.exists(uploadPath)) {
            Files.createDirectories(uploadPath);
        }

        try (InputStream inputStream = multipartFile.getInputStream()) {
            /*
             * Tạo ra đường dẫn đầy đủ, nó kết hợp uploadPath và file name để tạo ra đường dẫn đầy đủ của fie
             */
            Path filePath = uploadPath.resolve(fileName);
            /*
             * Sao chép data từ inputStream sang file chỉ định
             * - REPLACE_EXISTING ==> nếu file đã tồn tại ghi đè file mới lên. Nếu không sử dụng sẽ ném ngoại * lệ FileAlreadyExistsException khi file đã tồn tại và không thể ghi đè lên nó
             */
            Files.copy(inputStream, filePath, StandardCopyOption.REPLACE_EXISTING);
        } catch (IOException e) {
            throw new IOException("Could not save file: " + fileName, e);
        }
    }

    /*
     * chỉ xoá tệp trong thư mục chỉ định, thư mục con và các tệp nằm trong thư mục con không bị xoá
     */
    public static void cleanDir(String dir) {
        Path dirPath = Paths.get(dir);

        try {
            // lấy danh sách các file và dir trong trong thư mục đã cho
            Files.list(dirPath).forEach(file -> {
                if (!Files.isDirectory(file)) {
                    try {
                        Files.delete(file);
                    } catch (IOException e) {
                        LOGGER.error("Could not delete file: " + file);
                    }
                }
            });
        } catch (IOException e) {
            LOGGER.error("Could not list directory: " + dirPath);
        }
    }

    /*
     * Xoá thư mục và các tệp có trong thư mục. 
     * Nếu thư mục có thư mục con thì không thể xoá (thư mục chỉ định + thư mục con) mà chỉ có thể xoá các   * file nằm trong thư mục chỉ định
     */
    public static void removeDir(String dir) {
        cleanDir(dir);

        try {
            Files.delete(Paths.get(dir));
        } catch (IOException e) {
            LOGGER.error("Could not remove directory: " + dir);
        }
    }
}
```

**Xử lý lưu ảnh**

```java
@Entity
@Transient
public String getPhotosImagePath() {
    if (id == null || imagePath == null) return "/images/default-user.png";
    return "/user-photos/" + this.id + "/" + this.imagePath;
}

@Service
public void save(User user) {
    userRepo.save(user);
}

@Controller
@PostMapping("/users/save")
public String saveUser(User user, RedirectAttributes redirectAttributes,
                        // sẽ đọc name của input file
                       @RequestParam("image") MultipartFile multipartFile) throws IOException {
    if (!multipartFile.isEmpty()) {
/*
 * - cleanPath() trả về 1 path đã loại bỏ bất kỳ điều hướng tương đối ("./" và "../"), các dấu gạch chéo 
 * trùng lặp và byte null
 * - Objects.requireNonNull để ném một ngoại lệ NullPointerException nếu multipartFile.getOriginalFilename() * trả về giá trị null để tránh NullPointerExceptionn nếu multipartFile không có tên tệp gốc được liên kết 
 * với nó
 * - Mục đích sử dụng cleanPath mà không dùng thẳng getOriginalFilename() vì để tránh tên file có thể bị hack * và chứa các ký tự đặc biệt hoặc dấu chấm phân tách, gây ra lỗi
 */
        String fileName = StringUtils.cleanPath(Objects.requireNonNull(multipartFile.getOriginalFilename()));
        user.setImagePath(fileName);

        User savedUser = userService.save(user);

        String uploadDir = "user-photos/" + savedUser.getId();

        FileUploadUtils.cleanDir(uploadDir); // remove ảnh cũ trước khi lưu ảnh mới
        FileUploadUtils.saveFile(uploadDir, fileName, multipartFile);
    } else {
        if (user.getImagePath().isEmpty()) user.setImagePath(null);
        userService.save(user);
    }
    String fullName = user.getLastName() + " " + user.getFirstName();
    redirectAttributes.addFlashAttribute("message", "Nhân viên " + fullName + " đã được lưu thành công");
    String firstPartOfEmail = user.getEmail().split("@")[0];

    return "redirect:/users/page/1?sortField=id&sortType=asc&keyword=" + firstPartOfEmail;
}

/*
 * cấu hình các tài nguyên tĩnh như các tệp tin hình ảnh, css, js và các tài nguyên khác trong ứng dụng cho 
 * client request
 */
@Configuration
public class MvcConfig implements WebMvcConfigurer {
    @Override
    public void addResourceHandlers(ResourceHandlerRegistry registry) {
        // User
        exposeDirectory("user-photos", registry);
    }

    private void exposeDirectory(String logicalPath, ResourceHandlerRegistry registry) {
        Path path = Paths.get(logicalPath);
        String absolutePath = path.toFile().getAbsolutePath();

        registry.addResourceHandler("/" + logicalPath + "/**").addResourceLocations("file:/" + absolutePath + "/");
    }
}

// html
<div class="col-sm-8">
    <input type="hidden" th:field="*{imagePath}"/>
    <input type="file" id="fileImage" name="image" accept="image/png, image/jpeg"
           class="mb-2"/>
    <img id="thumbnail" alt="Photos preview" th:src="@{${user.photosImagePath}}" class="img-fluid"/>
</div>

// js
$(document).ready(function () {
    // sự kiện change để bắt thay đổi giá trị của checkbox, radio, select, input
    $("#fileImage").change(function () {
        let fileSize = this.files[0].size;
        let mb = 1024 * 1024; // 1mb = 1024 x 1024 kb = 1048576 bytes

        if (fileSize > mb) {
            // set thông báo cho required mặc định của thẻ input
            this.setCustomValidity("Bạn phải chọn ảnh có kích thước nhỏ hơn 1MB!");
            /*
             * - Nếu không sử dụng reportValidity() này thì khi chọn ảnh bị sai kích thước sẽ không hiển thị * thông báo ngay lập tức mà phải đợi nhấn submit mới hiển thị thông báo của setCustomValidity()
             * - Khi sử dụng thì nó sẽ thông báo ngay lập tức nếu lỗi mà không cần đợi submit mới hiển thị
             */
            this.reportValidity();
        } else {
            this.setCustomValidity("");
            showImageThumbnail(this);
        }

    });
});
// show ảnh khi chọn lên kế bên ô input
function showImageThumbnail(fileInput) {
    let file = fileInput.files[0];
    let reader = new FileReader();
    reader.onload = function (e) {
        $("#thumbnail").attr("src", e.target.result);
    };

    reader.readAsDataURL(file);
}
```

**Lưu ý khi sử dụng kích thước ảnh**

- Kích thước tệp ảnh nên từ 100kb đến 1mb
- Ảnh nên là jpeg hoặc webp
- Ảnh sản phẩm 800x800 đến 1200x1200 pixel, độ phân giải 72-96 dpi
- Ảnh nền 1920x1080 đến 2560x1440
- Ảnh quảng cáo 300x250 đến 728x90
- Ảnh minh hoạ 800x600 đến 1200x800
- Ảnh trong bài viết 1200x800 đến 1920x1080

**[⬆ Quay trở lại đầu trang](#mục-lục-nội-dung)**

## 3. Cập nhật

Để cập nhật thông tin user ta cần thực hiện các bước sau:

- B1: Chọn user muốn cập nhật và gửi request về server.
- B2: Viết hàm controller xử lý request điều hướng tới phần cập nhật thông tin
- B3: Sử dụng lại controller save

```java
// user
<a th:href="@{'/users/edit/' + ${user.id}}"></a>

@Controller
@GetMapping("/users/edit/{id}")
public String editUser(@PathVariable(name = "id") Integer id, Model model, RedirectAttributes redirectAttributes) {
    try {
        User user = userService.get(id);
        model.addAttribute("user", user);
        model.addAttribute("roles", roles);

        return "users/user_form";
    } catch (UserNotFoundException ex) {
        redirectAttributes.addFlashAttribute("message", ex.getMessage());

        return "redirect:/users";
    }
}

@Service
public User get(Integer id) throws UserNotFoundException {
    try {
        return userRepo.findById(id).get();
    } catch (Exception ex) {
/*
 * Khi sử dụng throw thì phải luôn dùng throws vì chắc chắn method này sẽ có trường hợp không thoả lúc đó sẽ * ném throw nếu không sử dụng throws thì khi xử dụng method này ở nơi khác lúc đó sẽ quên bắt lỗi lúc đó  
 * method xảy ra throw mà không bắt dẫn đến xảy ra ngoại lệ
 */
        throw new UserNotFoundException("Không tìm thấy nhân viên có id là " + id);
    }
}

public class UserNotFoundException extends Throwable {
    public UserNotFoundException(String s) {
        super(s);
    }
}
```

**[⬆ Quay trở lại đầu trang](#mục-lục-nội-dung)**

## Xem thêm bài viết khác

- [Chức năng](Day011.md)
- [Mã hoá mật khẩu với bcrypt](Day014.md)